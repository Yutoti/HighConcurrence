1. 最初状态：单线程请求数据库 -> 无法满足高并发场景要求；

2. 为了模拟高并发请求，使用CountDownLatch类，利用其中的await()和countDown()方法，模拟多个线程在某个时刻同时请求数据库。
-> 由于MySQL的默认最大连接数为100，无法建立更多的连接；

3. 使用数据库连接池技术（Tomcat jdbc pool），可以大大提升连接的使用率，提高并发数量（后面用的10000）。
-> 高并发秒杀场景通常逻辑是先SELECT，判断库存 > 0 再UPDATE，会有数据不一致的问题。

4. SELECT和UPDATE放在一个事务中，同时配合使用数据库层面上的加锁机制。

尝试的方案有：

1）先UPDATE再SELECT，判断后来SELECT出来的库存数目是否正确；


2）还是先SELECT，再UPDATE。

有两种方案：在SELECT上加排它锁，以及在UPDATE上加乐观锁。

在5000的并发量下，对比两种方案（悲观锁和乐观锁）结果：

> 乐观锁花费时间： 10693 ms

排它锁花费时间： 55436 ms

性能显然乐观锁比悲观锁优异很多。

（在此处需要让所有的秒杀子线程执行完后再执行main线程，以便统计时间，采用的是所有子线程先start再所有子线程join的方法）
